/**
 * Agent lifecycle MCP tools.
 *
 * Provides tools for managing agent work sessions:
 * - agent_start: Claims an item and writes assigned_agent to frontmatter
 * - agent_stop: Signals completion and adds work summary to work_log
 */
import { z } from 'zod';
import { createClient } from '../client/index.js';
/**
 * Valid agent names (lowercase, normalized).
 */
const VALID_AGENTS = [
    'murdock',
    'ba',
    'lynch',
    'amy',
    'hannibal',
    'face',
    'sosa',
    'tawnia',
];
/**
 * Zod schema for agent name validation.
 * Accepts case-insensitive input but validates against lowercase values.
 */
const AgentNameSchema = z
    .string()
    .transform((val) => val.toLowerCase())
    .refine((val) => VALID_AGENTS.includes(val), {
    message: `Agent must be one of: ${VALID_AGENTS.join(', ')}`,
});
/**
 * Input schema for agent_start tool.
 */
export const AgentStartSchema = z.object({
    itemId: z.string().min(1, 'itemId is required'),
    agent: AgentNameSchema,
    task_id: z.string().optional(),
});
/**
 * Input schema for agent_stop tool.
 */
export const AgentStopSchema = z.object({
    itemId: z.string().min(1, 'itemId is required'),
    agent: AgentNameSchema,
    status: z.enum(['success', 'failed']),
    summary: z.string().min(1, 'summary is required'),
    files_created: z.array(z.string()).optional(),
    files_modified: z.array(z.string()).optional(),
});
/**
 * Formats an error message from an API error response.
 */
function formatErrorMessage(error) {
    if (error instanceof Error) {
        const apiError = error;
        if (apiError.code === 'ECONNREFUSED') {
            return 'Connection refused - server may be unavailable';
        }
        return error.message;
    }
    const apiError = error;
    if (apiError.message) {
        return apiError.message;
    }
    return 'Unknown error occurred';
}
/**
 * Creates the HTTP client for API calls.
 */
function getClient() {
    return createClient({
        baseUrl: process.env.KANBAN_API_URL || 'http://localhost:3000',
        timeout: 30000,
        retries: 0,
    });
}
/**
 * Claims an item and writes assigned_agent to frontmatter.
 *
 * @param input - The agent start input parameters
 * @returns MCP tool response with success/error information
 */
export async function agentStart(input) {
    const client = getClient();
    try {
        const body = {
            itemId: input.itemId,
            agent: input.agent,
        };
        if (input.task_id) {
            body.task_id = input.task_id;
        }
        const response = await client.post('/api/agents/start', body);
        const data = response.data;
        return {
            content: [
                {
                    type: 'text',
                    text: JSON.stringify({
                        success: data.success,
                        message: `Agent ${data.agent} claimed item ${data.itemId}`,
                        itemId: data.itemId,
                        agent: data.agent,
                        timestamp: data.timestamp,
                        ...(data.task_id && { task_id: data.task_id }),
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        const errorMessage = formatErrorMessage(error);
        return {
            content: [
                {
                    type: 'text',
                    text: errorMessage,
                },
            ],
            isError: true,
        };
    }
}
/**
 * Signals completion and adds work summary to work_log.
 *
 * @param input - The agent stop input parameters
 * @returns MCP tool response with success/error information
 */
export async function agentStop(input) {
    const client = getClient();
    try {
        const body = {
            itemId: input.itemId,
            agent: input.agent,
            status: input.status,
            summary: input.summary,
        };
        if (input.files_created) {
            body.files_created = input.files_created;
        }
        if (input.files_modified) {
            body.files_modified = input.files_modified;
        }
        const response = await client.post('/api/agents/stop', body);
        const data = response.data;
        return {
            content: [
                {
                    type: 'text',
                    text: JSON.stringify({
                        success: data.success,
                        message: `Agent ${data.agent} completed work on item ${data.itemId}`,
                        itemId: data.itemId,
                        agent: data.agent,
                        status: data.status,
                        completed_at: data.completed_at,
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        const errorMessage = formatErrorMessage(error);
        return {
            content: [
                {
                    type: 'text',
                    text: errorMessage,
                },
            ],
            isError: true,
        };
    }
}
/**
 * Tool definitions for MCP server registration.
 */
export const agentTools = [
    {
        name: 'agent_start',
        description: 'Claims a work item for an agent and writes assigned_agent to the item frontmatter. ' +
            'Use this at the start of working on an item to signal that the agent has begun work. ' +
            'The item will be marked as claimed in board.json and the frontmatter will be updated.',
        inputSchema: {
            type: 'object',
            properties: {
                itemId: {
                    type: 'string',
                    description: 'The ID of the work item to claim',
                },
                agent: {
                    type: 'string',
                    description: `The agent name (one of: ${VALID_AGENTS.join(', ')})`,
                    enum: VALID_AGENTS,
                },
                task_id: {
                    type: 'string',
                    description: 'Optional task ID for tracking background tasks',
                },
            },
            required: ['itemId', 'agent'],
        },
    },
    {
        name: 'agent_stop',
        description: 'Signals that an agent has completed work on an item and adds a work summary to the work_log. ' +
            'Use this when finished working on an item to record what was done. ' +
            'The agent claim will be released and the summary will be appended to the item frontmatter.',
        inputSchema: {
            type: 'object',
            properties: {
                itemId: {
                    type: 'string',
                    description: 'The ID of the work item that was worked on',
                },
                agent: {
                    type: 'string',
                    description: `The agent name (one of: ${VALID_AGENTS.join(', ')})`,
                    enum: VALID_AGENTS,
                },
                status: {
                    type: 'string',
                    description: 'The completion status',
                    enum: ['success', 'failed'],
                },
                summary: {
                    type: 'string',
                    description: 'A brief summary of the work completed',
                },
                files_created: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Optional array of file paths that were created',
                },
                files_modified: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Optional array of file paths that were modified',
                },
            },
            required: ['itemId', 'agent', 'status', 'summary'],
        },
    },
];
//# sourceMappingURL=agents.js.map